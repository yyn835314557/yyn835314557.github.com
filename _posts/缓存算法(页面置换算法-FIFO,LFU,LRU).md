#缓存算法（页面置换算法）-FIFO、LFU、LRU


2. LFU(Least Frequently used):算法根据数据的历史访问频率来淘汰数据，其核心思想是“如果数据过去被访问多次，那么将来被访问的频率也更高”。
 LFU的每个数据块都有一个引用计数，所有数据块按照引用计数排序，具有相同引用计数的数据块则按照时间排序。
具体实现如下：	 
	 1. 新加入数据插入到队列尾部（因为引用计数为1）；
	 2. 队列中的数据被访问后，引用计数增加，队列重新排序；
	 3. 当需要淘汰数据时，将已经排序的列表最后的数据块删除。

3. LRU（Least recently used，最近最少使用）

	- 原理：算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。最常见的实现是使用一个链表保存缓存数据，详细算法实现如下：
	- 实现:最常见的实现是使用一个链表保存缓存数据
		 1. 新数据插入到链表头部；
		 2. 每当缓存命中（即缓存数据被访问），则将数据移到链表头部；
		 3. 当链表满的时候，将链表尾部的数据丢弃。
	- 分析:
		 - 命中率：
		 	 当存在热点数据时，LRU的效率很好，但偶发性的、周期性的批量操作会导致LRU命中率急剧下降，缓存污染情况比较严重。
		 - 复杂度：
		 	 实现简单。
		 - 代价：
		   	 命中时需要遍历链表，找到命中的数据块索引，然后需要将数据移到头部。
 ```Swift
 class Node<K,V>
 ```