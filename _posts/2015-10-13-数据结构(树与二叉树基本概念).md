---
layout: post
title: "数据结构(树与二叉树基本概念)"
date: 2015-10-13
comments: true
categories: dataStructure
tags: [data Structure ,binary tree]
keywords: binary tree 
description: 数据结构(树与二叉树基本概念)
---

前面的文章主要关于iOS开发的，这篇文章我们来讨论一下数据结构中十分重要的二叉树及其基本概念。

#### 树的基本概念
 
 树是 N(N>=0) 个结点的有限集合, N=0 时，称为空树，对任意的非空树应该满足: 有且仅有一个特定的称为根的结点；当 N > 1 时，其余结点可分为 m(m>0) 个互不相交的有限集合 T1,T2,T3,...,Tm, 其中每一个集合本身又是一棵树，并且称为根节点的子树。

 树是一种递归的数据结构(以为其定义的递归的)；树作为一种逻辑结构，同时也是分层结构具有如下两个特点：

 	1. 树的根节点没有前驱结点，除了根节点之外的所有节点有且只有一个前驱结点
 	2. 树中的所有结点可以有零个或多个后继结点

 树适合表示具有层次结构的数据。树中的某个结点最多只和上一层的一个结点有直接关系，根结点没有直接上层结点，树中每个结点与其下一层的零个或者多个结点有直接关系，因此，在 n 个结点的树中有 n-1 条边。

 树的基本术语:

 - 祖先结点、子孙结点；双亲结点、孩子节点；兄弟结点的概念；
 - 树中一个结点的孩子结点的个数称为该结点的 **度** ,树中结点的最大数称为 *树的度* ,
 - 度大于零的结点称为分支结点(非终端结点)，度为零的结点称为叶子结点(终端结点)
 - 结点的层次(根结点为第一层，它的子结点为第二层，以此类推)
 - 结点的深度(自顶向下逐层累加)
 - 结点的高度(自底向上逐层累加)
 - 树的高度(深度)是树中结点的最大层数
 - 有序树和无序树: 树的结点的子树从左至右是有次序的，不能交换，称为有序树，反之则称之为无序树
 - 路径和路径长度: 树中两个结点之间的路径是由这两个结点之间所经过的结点序列构成的，而路径长度是路径上所经过的边的个数。
 - 森林: 森林是 m(m>=0) 棵互不相交的树的集合。只要把树的根结点删去就成了森林，反之给 n 棵独立的树加上一个结点，并把 n 棵树作为该结点的子树，则森林就变成了树。

 树的基本性质如下:

 - 树中的结点数等于所有结点的度数加1
 - 度为 m 的树中第 i 层上至多有 m ^ (i-1) 个结点 (i>=1),若想等则树的每一层都全部填充完毕
 - 高度为 h 的 m 叉树至多有 (m^h -1)(m-1) 个结点
 - 具有 n 个结点的 m 叉树的最小高度为 logm (n(m-1)+1) (向上取整)


#### 二叉树的基本概念

 二叉树的特点是每个结点至多只有两颗子树，并且，二叉树的子树有左右之分，其次序不能颠倒。二叉树也可以以递归的形式定义。

 > 二叉树与度为2的有序树的区别:
   	 1. 度为2的有序树至少有三个结点，而二叉树可以为空；
   	 2. 度为2的有序树的孩子结点的左右次序是相对于另一个孩子结点而言，如果某个结点只有一个孩子结点这个孩子结点就无需区分其左右次序，而二叉树无论其孩子树是否为2，均需确定其左右次序，二叉树的结点次序不是相对于另一个孩子结点而言，而是确定的。

 几种特殊的二叉树:

 - 满二叉树: 高度为 h 的二叉树的结点为 2 ^ h -1 ;叶子结点都集中在最下一层，左孩子为 2i ,右孩子为 2i + 1;双亲结点为 i/2(去下整) ；
 - 完全二叉树:
 	- 若 i <= n/2（取下整），则 i 为分支结点，否则为孩子结点。
 	- 若 n 为奇数，则每个分支结点都有左右孩子，反之只有左子女，
 	- 如果有度为1的结点，只可能有一个，且该结点只有左孩子没有右孩子
 - 二叉查找树（Binary Search Tree），（又：二叉搜索树，二叉排序树）:
 	- 它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。
 - 平衡二叉树: 
 	- 树上任意结点的左子树和右子树的深度之差不超过1。

 二叉树的性质: 

 - 非空二叉树上叶子结点数等于度为2的结点数加1，N0 = N2 + 1

 > 总结点树为 N = N0 + N1 + N2 ,每个结点都从一个分支而来(根结点除外)，分支是由度为1，2的结点射出的， N = N1 + 2N2 + 1 ; 又因为 N = N1 + N2 + N3 ; 所以 N0 = N2 + 1 。 
 
 - 具有 N 个结点的完全二叉树的高度为 log2(N+1) 取上整
 	
#### 二叉树的存储结构

 - 顺序存储结构:
 	 - 用一组连续的存储单元依次自上而下，至左至右存储完全二叉树上的结点元素将完全二叉树上编号为 i 的结点元素存储在某个数组下标为 i-1 的分量中，顺序存储结构比较适合完全二叉树与满二叉树。

 	 > 注意区别树的顺序存储结构与二叉树的顺序存储结构。
 	  树的顺序存储结构中，数组下标代表结点编号，下标上所存的内容指示了结点之间的关系。而在二叉树顺序存储结构中，数组下标即代表了结点编号，也指示了树中各结点之间的关系。二叉树属于树，二叉树都可以用树的存储结构来存储。

 - 链式存储结构:

 	 - 因为顺序存储结构对空间利用率较低，因此一般二叉树都采用链式存储结构。用一个链表存储一个二叉树，二叉树中的每个结点用链表的一个链结点来存储。在二叉树中，结点结构通常包括若干数据域以及若干指针域。二叉链表至少包含 数据域，指针域(lchild和rchild)。
 	 - 在含有n个结点的二叉链表中含有 n+1 个空链域

 ```C
 typedf struct BinaryTreeNode{
 	int data;
 	struct BinaryTreeNode *lchild,*rchild;
 }BiTNode,*BiTree;
 ```

#### 二叉树的遍历

 所谓二叉树遍历，是指按照某条搜索路径访问树中的每个结点，使得每个结点均被访问一次，而且仅被访问一次。

 1. 先序遍历(PreOrder): 访问根节点，先序遍历左子树，先序遍历右子树。
  	
 	```
 	void PreOrder(BiTree T){
 		if(T != NULL){
 		// 访问根节点，之后递归访问左子树，右子树
 			visit(T);
 			PreOrder(T->lchild);
 			PreOrder(T->rchild);
 		}
 	}
 	```

 2. 中序遍历(InOrder): 中序遍历左子树，访问根结点，中序遍历右子树。

 	```
 	void InOrder(BiTree T){
	 	if(T != NULL){
	 		InOrder(T ->lchild);
	 		visit(T);
	 		InOrder(T ->rchild);
 		}
 	}
 	```

 3. 后序遍历(PostOrder): 后续遍历左子树，后序遍历右子树，访问根结点。

 	```
 	void PostOrder(BiTree T){
 		if(T != 0){
 			PostOrder(T ->lchild);
 			PostOrder(T ->rchild);
 			visit(T);
 		}
 	}
 	```

 4. 层次遍历(宽度优先遍历): 按照1，2，3，4... 的层次顺序，对二叉树中的各个结点进行访问(使用队列)

 	```
 	void LevelOrder(BiTree T){
 		InitQueue(Q); //初始化辅助队列
 		BiTree p;
 		EnQueue(W,T);
 		while(!IsEmpty(Q)){
 			DeQueue(T);
 			visit(p);
 			if(p->lchild != NULL){
 				EnQueue(Q,p->lchild);
 			}
 			if(p->rchild != NULL){
 				EnQueue(Q,p->rchild);
 			}
 		}
 	}
 	```

 5. 由遍历序列构造二叉树:

 	 知道先序序列和中序序列可以唯一确定二叉树
 	 知道后续遍历和中序遍历可以唯一确定二叉树
 	 知道层次序列和中序序列也可以唯一确定二叉树

 > Note:
  知道线序遍历和后续遍历不能唯一确定一个二叉树。	 


#### 线索二叉树

 二叉树的遍历是以一定的规则将二叉树中的结点排成一个线性序列，其实质就是对一个非线性结构进行线性化操作，使得每一个结点都有一个前驱和后继(第一个和最后一个除外)。

 传统的链式存储结构仅能提供一种父子关系，不能直接得到结点的前驱和后继，我们利用二叉链表中的大量空链域存放指向其直接前驱和后继的指针。

 引入线索二叉树是为了加快查找结点前驱和后继的速度。

 > N个结点的二叉树有 N+1 个空指针，因为总的空指针为 2N0 + N1 ,又因为 N0 = N2 + 1 。 所以 N0+N1+N2 = N+1

 在二叉树线索化时若无左子树，另 lchild 指向其前驱结点；若无右子树时，另 rchild指向其后继结点，还需要增加两个标志域(ltag,rtag)来表明当前指针域所指向的对象是左(右)结点还是前驱(后继)；0表示左(右)孩子，1表示前驱(后继)。

 二叉线索树的数据结构如下所示:

 ```
 typedf struct ThreadNode{
 	int data;
 	struct ThreadNode *lchild,*rchild;
 	int ltag,rtag; //左右线索标志
 };
 ```

 二叉线索树的构造：
 
